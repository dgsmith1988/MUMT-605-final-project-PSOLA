clear;
addpath(".\yin")
filename = 'flute2.wav';
[x, Fs] = audioread(filename);
T = 1/Fs;
results = yin(filename);

figure;
subplot(2, 1, 1);
plot((1:length(x))/Fs, x);
xlim([0 3.5])
title('Original x[n]');
subplot(2, 1, 2);
time_axis = (1:length(results.f0)) * results.hop * T;
plot(time_axis, results.f0);
title("YIN Output");
xlim([0 3.5]);

f0 = results.f0;
f0((isnan(f0))) = 0;
% DAFX_pitch_marks = findpitchmarks(x, Fs, f0, results.hop, results.wsize);
my_pitch_marks = getPitchMarks(x, Fs, f0, results.hop, results.wsize);

%set all the unvoiced frames to have a fundamental frequency for easier
%processing later
first_non_zero = find(f0, 1);
zero = find(~f0);
change_index = find(diff(zero) > 1);
f0(1:change_index) = f0(first_non_zero);
ending_index = zero(change_index+1);
f0(ending_index:end) = f0(ending_index-1);
P0 = round(Fs/f0);

alpha = 1.25; %time-stretch parameter

%find the first frame where the current pitch mark exists, this can be
%redone in a more elegant fashion later, skip the end points for now to
%make things easier and not deal with the corner cases
output = zeros(1, alpha*length(x));
output_pitch_mark = P0(1);

while output_pitch_mark < length(output)
    [~, i] = min( abs(alpha*my_pitch_marks - output_pitch_mark) );
    local_P0 = P0(i);
    L = 2*local_P0 + 1;
    i_upper = my_pitch_marks(i) + local_P0;
    i_lower = my_pitch_marks(i) - local_P0;
    windowed_segment = hanning(L, 'symmetric') .* x(i_lower:i_upper);
    
    out_start = 
    
    output_pitch_mark = output_pitch_mark + local_P0;
end

for j = 2:length(my_pitch_marks) - 1
    pm = my_pitch_marks(j);
    for i = 1:length(f0)
        lower_bound = 1 + (i-1)*results.hop;
        upper_bound = lower_bound + results.wsize - 1;
        if pm <= upper_bound && pm >= lower_bound
            P0 = round(Fs/f0(i));
            break
        end
    end
    L = 2*P0 + 1;
    window = hanning(L, 'symmetric');
    upper = pm + floor(L/2);
    lower = pm - floor(L/2);
    extract = x(lower:upper) .* window;
end
